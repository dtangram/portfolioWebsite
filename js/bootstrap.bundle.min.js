/*!
  * Bootstrap v4.1.3 (https://getbootstrap.com/)
  * Copyright 2011-2018 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
  */
!(function (e, t) { typeof exports === 'object' && typeof module !== 'undefined' ? t(exports, require('jquery')) : typeof define === 'function' && define.amd ? define(['exports', 'jquery'], t) : t(e.bootstrap = {}, e.jQuery); }(this, (e, t) => {
  function i(e, t) { for (let n = 0; n < t.length; n++) { const i = t[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, 'value' in i && (i.writable = !0), Object.defineProperty(e, i.key, i); } } function s(e, t, n) { return t && i(e.prototype, t), n && i(e, n), e; } function l(r) {
    for (let e = 1; e < arguments.length; e++) {
      var o = arguments[e] != null ? arguments[e] : {}; let t = Object.keys(o); typeof Object.getOwnPropertySymbols === 'function' && (t = t.concat(Object.getOwnPropertySymbols(o).filter(e => Object.getOwnPropertyDescriptor(o, e).enumerable))), t.forEach((e) => {
        let t; let n; let i; t = r, i = o[n = e], n in t ? Object.defineProperty(t, n, {
          value: i, enumerable: !0, configurable: !0, writable: !0,
        }) : t[n] = i;
      });
    } return r;
  } for (var r, n, o, a, c, u, f, h, d, p, m, g, _, v, y, E, b, w, C, T, S, D, A, I, O, N, k, x, P, L, j, H, M, F, W, R, U, B, q, K, Q, Y, V, z, G, J, Z, X, $, ee, te, ne, ie, re, oe, se, ae, le, ce, ue, fe, he, de, pe, me, ge, _e, ve, ye, Ee, be, we = (function (i) {
      const t = 'transitionend'; function e(e) { const t = this; let n = !1; return i(this).one(l.TRANSITION_END, () => { n = !0; }), setTimeout(() => { n || l.triggerTransitionEnd(t); }, e), this; } var l = {
        TRANSITION_END: 'bsTransitionEnd', getUID(e) { for (;e += ~~(1e6 * Math.random()), document.getElementById(e););return e; }, getSelectorFromElement(e) { let t = e.getAttribute('data-target'); t && t !== '#' || (t = e.getAttribute('href') || ''); try { return document.querySelector(t) ? t : null; } catch (e) { return null; } }, getTransitionDurationFromElement(e) { if (!e) return 0; let t = i(e).css('transition-duration'); return parseFloat(t) ? (t = t.split(',')[0], 1e3 * parseFloat(t)) : 0; }, reflow(e) { return e.offsetHeight; }, triggerTransitionEnd(e) { i(e).trigger(t); }, supportsTransitionEnd() { return Boolean(t); }, isElement(e) { return (e[0] || e).nodeType; }, typeCheckConfig(e, t, n) { for (const i in n) if (Object.prototype.hasOwnProperty.call(n, i)) { const r = n[i]; const o = t[i]; const s = o && l.isElement(o) ? 'element' : (a = o, {}.toString.call(a).match(/\s([a-z]+)/i)[1].toLowerCase()); if (!new RegExp(r).test(s)) throw new Error(`${e.toUpperCase()}: Option "${i}" provided type "${s}" but expected type "${r}".`); } let a; },
      }; return i.fn.emulateTransitionEnd = e, i.event.special[l.TRANSITION_END] = { bindType: t, delegateType: t, handle(e) { if (i(e.target).is(this)) return e.handleObj.handler.apply(this, arguments); } }, l;
    }(t = t && t.hasOwnProperty('default') ? t.default : t)), Ce = (n = 'alert', a = `.${o = 'bs.alert'}`, c = (r = t).fn[n], u = { CLOSE: `close${a}`, CLOSED: `closed${a}`, CLICK_DATA_API: `click${a}.data-api` }, f = 'alert', h = 'fade', d = 'show', p = (function () { function i(e) { this._element = e; } const e = i.prototype; return e.close = function (e) { let t = this._element; e && (t = this._getRootElement(e)), this._triggerCloseEvent(t).isDefaultPrevented() || this._removeElement(t); }, e.dispose = function () { r.removeData(this._element, o), this._element = null; }, e._getRootElement = function (e) { const t = we.getSelectorFromElement(e); let n = !1; return t && (n = document.querySelector(t)), n || (n = r(e).closest(`.${f}`)[0]), n; }, e._triggerCloseEvent = function (e) { const t = r.Event(u.CLOSE); return r(e).trigger(t), t; }, e._removeElement = function (t) { const n = this; if (r(t).removeClass(d), r(t).hasClass(h)) { const e = we.getTransitionDurationFromElement(t); r(t).one(we.TRANSITION_END, e => n._destroyElement(t, e)).emulateTransitionEnd(e); } else this._destroyElement(t); }, e._destroyElement = function (e) { r(e).detach().trigger(u.CLOSED).remove(); }, i._jQueryInterface = function (n) { return this.each(function () { const e = r(this); let t = e.data(o); t || (t = new i(this), e.data(o, t)), n === 'close' && t[n](this); }); }, i._handleDismiss = function (t) { return function (e) { e && e.preventDefault(), t.close(this); }; }, s(i, null, [{ key: 'VERSION', get() { return '4.1.3'; } }]), i; }()), r(document).on(u.CLICK_DATA_API, '[data-dismiss="alert"]', p._handleDismiss(new p())), r.fn[n] = p._jQueryInterface, r.fn[n].Constructor = p, r.fn[n].noConflict = function () { return r.fn[n] = c, p._jQueryInterface; }, p), Te = (g = 'button', v = `.${_ = 'bs.button'}`, y = '.data-api', E = (m = t).fn[g], b = 'active', w = 'btn', T = '[data-toggle^="button"]', S = '[data-toggle="buttons"]', D = 'input', A = '.active', I = '.btn', O = { CLICK_DATA_API: `click${v}${y}`, FOCUS_BLUR_DATA_API: `${(C = 'focus') + v + y} blur${v}${y}` }, N = (function () { function n(e) { this._element = e; } const e = n.prototype; return e.toggle = function () { let e = !0; let t = !0; const n = m(this._element).closest(S)[0]; if (n) { const i = this._element.querySelector(D); if (i) { if (i.type === 'radio') if (i.checked && this._element.classList.contains(b))e = !1; else { const r = n.querySelector(A); r && m(r).removeClass(b); } if (e) { if (i.hasAttribute('disabled') || n.hasAttribute('disabled') || i.classList.contains('disabled') || n.classList.contains('disabled')) return; i.checked = !this._element.classList.contains(b), m(i).trigger('change'); }i.focus(), t = !1; } }t && this._element.setAttribute('aria-pressed', !this._element.classList.contains(b)), e && m(this._element).toggleClass(b); }, e.dispose = function () { m.removeData(this._element, _), this._element = null; }, n._jQueryInterface = function (t) { return this.each(function () { let e = m(this).data(_); e || (e = new n(this), m(this).data(_, e)), t === 'toggle' && e[t](); }); }, s(n, null, [{ key: 'VERSION', get() { return '4.1.3'; } }]), n; }()), m(document).on(O.CLICK_DATA_API, T, (e) => { e.preventDefault(); let t = e.target; m(t).hasClass(w) || (t = m(t).closest(I)), N._jQueryInterface.call(m(t), 'toggle'); }).on(O.FOCUS_BLUR_DATA_API, T, (e) => { const t = m(e.target).closest(I)[0]; m(t).toggleClass(C, /^focus(in)?$/.test(e.type)); }), m.fn[g] = N._jQueryInterface, m.fn[g].Constructor = N, m.fn[g].noConflict = function () { return m.fn[g] = E, N._jQueryInterface; }, N), Se = (x = 'carousel', L = `.${P = 'bs.carousel'}`, j = '.data-api', H = (k = t).fn[x], M = {
      interval: 5e3, keyboard: !0, slide: !1, pause: 'hover', wrap: !0,
    }, F = {
      interval: '(number|boolean)', keyboard: 'boolean', slide: '(boolean|string)', pause: '(string|boolean)', wrap: 'boolean',
    }, W = 'next', R = 'prev', U = 'left', B = 'right', q = {
      SLIDE: `slide${L}`, SLID: `slid${L}`, KEYDOWN: `keydown${L}`, MOUSEENTER: `mouseenter${L}`, MOUSELEAVE: `mouseleave${L}`, TOUCHEND: `touchend${L}`, LOAD_DATA_API: `load${L}${j}`, CLICK_DATA_API: `click${L}${j}`,
    }, K = 'carousel', Q = 'active', Y = 'slide', V = 'carousel-item-right', z = 'carousel-item-left', G = 'carousel-item-next', J = 'carousel-item-prev', Z = '.active', X = '.active.carousel-item', $ = '.carousel-item', ee = '.carousel-item-next, .carousel-item-prev', te = '.carousel-indicators', ne = '[data-slide], [data-slide-to]', ie = '[data-ride="carousel"]', re = (function () {
      function o(e, t) { this._items = null, this._interval = null, this._activeElement = null, this._isPaused = !1, this._isSliding = !1, this.touchTimeout = null, this._config = this._getConfig(t), this._element = k(e)[0], this._indicatorsElement = this._element.querySelector(te), this._addEventListeners(); } const e = o.prototype; return e.next = function () { this._isSliding || this._slide(W); }, e.nextWhenVisible = function () { !document.hidden && k(this._element).is(':visible') && k(this._element).css('visibility') !== 'hidden' && this.next(); }, e.prev = function () { this._isSliding || this._slide(R); }, e.pause = function (e) { e || (this._isPaused = !0), this._element.querySelector(ee) && (we.triggerTransitionEnd(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null; }, e.cycle = function (e) { e || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config.interval && !this._isPaused && (this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval)); }, e.to = function (e) { const t = this; this._activeElement = this._element.querySelector(X); const n = this._getItemIndex(this._activeElement); if (!(e > this._items.length - 1 || e < 0)) if (this._isSliding)k(this._element).one(q.SLID, () => t.to(e)); else { if (n === e) return this.pause(), void this.cycle(); const i = n < e ? W : R; this._slide(i, this._items[e]); } }, e.dispose = function () { k(this._element).off(L), k.removeData(this._element, P), this._items = null, this._config = null, this._element = null, this._interval = null, this._isPaused = null, this._isSliding = null, this._activeElement = null, this._indicatorsElement = null; }, e._getConfig = function (e) { return e = l({}, M, e), we.typeCheckConfig(x, e, F), e; }, e._addEventListeners = function () { const t = this; this._config.keyboard && k(this._element).on(q.KEYDOWN, e => t._keydown(e)), this._config.pause === 'hover' && (k(this._element).on(q.MOUSEENTER, e => t.pause(e)).on(q.MOUSELEAVE, e => t.cycle(e)), 'ontouchstart' in document.documentElement && k(this._element).on(q.TOUCHEND, () => { t.pause(), t.touchTimeout && clearTimeout(t.touchTimeout), t.touchTimeout = setTimeout(e => t.cycle(e), 500 + t._config.interval); })); }, e._keydown = function (e) { if (!/input|textarea/i.test(e.target.tagName)) switch (e.which) { case 37: e.preventDefault(), this.prev(); break; case 39: e.preventDefault(), this.next(); } }, e._getItemIndex = function (e) { return this._items = e && e.parentNode ? [].slice.call(e.parentNode.querySelectorAll($)) : [], this._items.indexOf(e); }, e._getItemByDirection = function (e, t) { const n = e === W; const i = e === R; const r = this._getItemIndex(t); const o = this._items.length - 1; if ((i && r === 0 || n && r === o) && !this._config.wrap) return t; const s = (r + (e === R ? -1 : 1)) % this._items.length; return s === -1 ? this._items[this._items.length - 1] : this._items[s]; }, e._triggerSlideEvent = function (e, t) {
        const n = this._getItemIndex(e); const i = this._getItemIndex(this._element.querySelector(X)); const r = k.Event(q.SLIDE, {
          relatedTarget: e, direction: t, from: i, to: n,
        }); return k(this._element).trigger(r), r;
      }, e._setActiveIndicatorElement = function (e) { if (this._indicatorsElement) { const t = [].slice.call(this._indicatorsElement.querySelectorAll(Z)); k(t).removeClass(Q); const n = this._indicatorsElement.children[this._getItemIndex(e)]; n && k(n).addClass(Q); } }, e._slide = function (e, t) {
        let n; let i; let r; const o = this; const s = this._element.querySelector(X); const a = this._getItemIndex(s); const l = t || s && this._getItemByDirection(e, s); const c = this._getItemIndex(l); const u = Boolean(this._interval); if (e === W ? (n = z, i = G, r = U) : (n = V, i = J, r = B), l && k(l).hasClass(Q)) this._isSliding = !1; else if (!this._triggerSlideEvent(l, r).isDefaultPrevented() && s && l) {
          this._isSliding = !0, u && this.pause(), this._setActiveIndicatorElement(l); const f = k.Event(q.SLID, {
            relatedTarget: l, direction: r, from: a, to: c,
          }); if (k(this._element).hasClass(Y)) { k(l).addClass(i), we.reflow(l), k(s).addClass(n), k(l).addClass(n); const h = we.getTransitionDurationFromElement(s); k(s).one(we.TRANSITION_END, () => { k(l).removeClass(`${n} ${i}`).addClass(Q), k(s).removeClass(`${Q} ${i} ${n}`), o._isSliding = !1, setTimeout(() => k(o._element).trigger(f), 0); }).emulateTransitionEnd(h); } else k(s).removeClass(Q), k(l).addClass(Q), this._isSliding = !1, k(this._element).trigger(f); u && this.cycle();
        }
      }, o._jQueryInterface = function (i) { return this.each(function () { let e = k(this).data(P); let t = l({}, M, k(this).data()); typeof i === 'object' && (t = l({}, t, i)); const n = typeof i === 'string' ? i : t.slide; if (e || (e = new o(this, t), k(this).data(P, e)), typeof i === 'number')e.to(i); else if (typeof n === 'string') { if (typeof e[n] === 'undefined') throw new TypeError(`No method named "${n}"`); e[n](); } else t.interval && (e.pause(), e.cycle()); }); }, o._dataApiClickHandler = function (e) { const t = we.getSelectorFromElement(this); if (t) { const n = k(t)[0]; if (n && k(n).hasClass(K)) { const i = l({}, k(n).data(), k(this).data()); const r = this.getAttribute('data-slide-to'); r && (i.interval = !1), o._jQueryInterface.call(k(n), i), r && k(n).data(P).to(r), e.preventDefault(); } } }, s(o, null, [{ key: 'VERSION', get() { return '4.1.3'; } }, { key: 'Default', get() { return M; } }]), o;
    }()), k(document).on(q.CLICK_DATA_API, ne, re._dataApiClickHandler), k(window).on(q.LOAD_DATA_API, () => { for (let e = [].slice.call(document.querySelectorAll(ie)), t = 0, n = e.length; t < n; t++) { const i = k(e[t]); re._jQueryInterface.call(i, i.data()); } }), k.fn[x] = re._jQueryInterface, k.fn[x].Constructor = re, k.fn[x].noConflict = function () { return k.fn[x] = H, re._jQueryInterface; }, re), De = (se = 'collapse', le = `.${ae = 'bs.collapse'}`, ce = (oe = t).fn[se], ue = { toggle: !0, parent: '' }, fe = { toggle: 'boolean', parent: '(string|element)' }, he = {
      SHOW: `show${le}`, SHOWN: `shown${le}`, HIDE: `hide${le}`, HIDDEN: `hidden${le}`, CLICK_DATA_API: `click${le}.data-api`,
    }, de = 'show', pe = 'collapse', me = 'collapsing', ge = 'collapsed', _e = 'width', ve = 'height', ye = '.show, .collapsing', Ee = '[data-toggle="collapse"]', be = (function () { function a(t, e) { this._isTransitioning = !1, this._element = t, this._config = this._getConfig(e), this._triggerArray = oe.makeArray(document.querySelectorAll(`[data-toggle="collapse"][href="#${t.id}"],[data-toggle="collapse"][data-target="#${t.id}"]`)); for (let n = [].slice.call(document.querySelectorAll(Ee)), i = 0, r = n.length; i < r; i++) { const o = n[i]; const s = we.getSelectorFromElement(o); const a = [].slice.call(document.querySelectorAll(s)).filter(e => e === t); s !== null && a.length > 0 && (this._selector = s, this._triggerArray.push(o)); } this._parent = this._config.parent ? this._getParent() : null, this._config.parent || this._addAriaAndCollapsedClass(this._element, this._triggerArray), this._config.toggle && this.toggle(); } const e = a.prototype; return e.toggle = function () { oe(this._element).hasClass(de) ? this.hide() : this.show(); }, e.show = function () { let e; let t; const n = this; if (!this._isTransitioning && !oe(this._element).hasClass(de) && (this._parent && (e = [].slice.call(this._parent.querySelectorAll(ye)).filter(e => e.getAttribute('data-parent') === n._config.parent)).length === 0 && (e = null), !(e && (t = oe(e).not(this._selector).data(ae)) && t._isTransitioning))) { const i = oe.Event(he.SHOW); if (oe(this._element).trigger(i), !i.isDefaultPrevented()) { e && (a._jQueryInterface.call(oe(e).not(this._selector), 'hide'), t || oe(e).data(ae, null)); const r = this._getDimension(); oe(this._element).removeClass(pe).addClass(me), this._element.style[r] = 0, this._triggerArray.length && oe(this._triggerArray).removeClass(ge).attr('aria-expanded', !0), this.setTransitioning(!0); const o = `scroll${r[0].toUpperCase() + r.slice(1)}`; const s = we.getTransitionDurationFromElement(this._element); oe(this._element).one(we.TRANSITION_END, () => { oe(n._element).removeClass(me).addClass(pe).addClass(de), n._element.style[r] = '', n.setTransitioning(!1), oe(n._element).trigger(he.SHOWN); }).emulateTransitionEnd(s), this._element.style[r] = `${this._element[o]}px`; } } }, e.hide = function () { const e = this; if (!this._isTransitioning && oe(this._element).hasClass(de)) { const t = oe.Event(he.HIDE); if (oe(this._element).trigger(t), !t.isDefaultPrevented()) { const n = this._getDimension(); this._element.style[n] = `${this._element.getBoundingClientRect()[n]}px`, we.reflow(this._element), oe(this._element).addClass(me).removeClass(pe).removeClass(de); const i = this._triggerArray.length; if (i > 0) for (let r = 0; r < i; r++) { const o = this._triggerArray[r]; const s = we.getSelectorFromElement(o); if (s !== null)oe([].slice.call(document.querySelectorAll(s))).hasClass(de) || oe(o).addClass(ge).attr('aria-expanded', !1); } this.setTransitioning(!0); this._element.style[n] = ''; const a = we.getTransitionDurationFromElement(this._element); oe(this._element).one(we.TRANSITION_END, () => { e.setTransitioning(!1), oe(e._element).removeClass(me).addClass(pe).trigger(he.HIDDEN); }).emulateTransitionEnd(a); } } }, e.setTransitioning = function (e) { this._isTransitioning = e; }, e.dispose = function () { oe.removeData(this._element, ae), this._config = null, this._parent = null, this._element = null, this._triggerArray = null, this._isTransitioning = null; }, e._getConfig = function (e) { return (e = l({}, ue, e)).toggle = Boolean(e.toggle), we.typeCheckConfig(se, e, fe), e; }, e._getDimension = function () { return oe(this._element).hasClass(_e) ? _e : ve; }, e._getParent = function () { const n = this; let e = null; we.isElement(this._config.parent) ? (e = this._config.parent, typeof this._config.parent.jquery !== 'undefined' && (e = this._config.parent[0])) : e = document.querySelector(this._config.parent); const t = `[data-toggle="collapse"][data-parent="${this._config.parent}"]`; const i = [].slice.call(e.querySelectorAll(t)); return oe(i).each((e, t) => { n._addAriaAndCollapsedClass(a._getTargetFromElement(t), [t]); }), e; }, e._addAriaAndCollapsedClass = function (e, t) { if (e) { const n = oe(e).hasClass(de); t.length && oe(t).toggleClass(ge, !n).attr('aria-expanded', n); } }, a._getTargetFromElement = function (e) { const t = we.getSelectorFromElement(e); return t ? document.querySelector(t) : null; }, a._jQueryInterface = function (i) { return this.each(function () { const e = oe(this); let t = e.data(ae); const n = l({}, ue, e.data(), typeof i === 'object' && i ? i : {}); if (!t && n.toggle && /show|hide/.test(i) && (n.toggle = !1), t || (t = new a(this, n), e.data(ae, t)), typeof i === 'string') { if (typeof t[i] === 'undefined') throw new TypeError(`No method named "${i}"`); t[i](); } }); }, s(a, null, [{ key: 'VERSION', get() { return '4.1.3'; } }, { key: 'Default', get() { return ue; } }]), a; }()), oe(document).on(he.CLICK_DATA_API, Ee, function (e) { e.currentTarget.tagName === 'A' && e.preventDefault(); const n = oe(this); const t = we.getSelectorFromElement(this); const i = [].slice.call(document.querySelectorAll(t)); oe(i).each(function () { const e = oe(this); const t = e.data(ae) ? 'toggle' : n.data(); be._jQueryInterface.call(e, t); }); }), oe.fn[se] = be._jQueryInterface, oe.fn[se].Constructor = be, oe.fn[se].noConflict = function () { return oe.fn[se] = ce, be._jQueryInterface; }, be), Ae = typeof window !== 'undefined' && typeof document !== 'undefined', Ie = ['Edge', 'Trident', 'Firefox'], Oe = 0, Ne = 0; Ne < Ie.length; Ne += 1) if (Ae && navigator.userAgent.indexOf(Ie[Ne]) >= 0) { Oe = 1; break; } const ke = Ae && window.Promise ? function (e) { let t = !1; return function () { t || (t = !0, window.Promise.resolve().then(() => { t = !1, e(); })); }; } : function (e) { let t = !1; return function () { t || (t = !0, setTimeout(() => { t = !1, e(); }, Oe)); }; }; function xe(e) { return e && {}.toString.call(e) === '[object Function]'; } function Pe(e, t) { if (e.nodeType !== 1) return []; const n = getComputedStyle(e, null); return t ? n[t] : n; } function Le(e) { return e.nodeName === 'HTML' ? e : e.parentNode || e.host; } function je(e) { if (!e) return document.body; switch (e.nodeName) { case 'HTML': case 'BODY': return e.ownerDocument.body; case '#document': return e.body; } const t = Pe(e); const n = t.overflow; const i = t.overflowX; const r = t.overflowY; return /(auto|scroll|overlay)/.test(n + r + i) ? e : je(Le(e)); } const He = Ae && !(!window.MSInputMethodContext || !document.documentMode); const Me = Ae && /MSIE 10/.test(navigator.userAgent); function Fe(e) { return e === 11 ? He : e === 10 ? Me : He || Me; } function We(e) { if (!e) return document.documentElement; for (var t = Fe(10) ? document.body : null, n = e.offsetParent; n === t && e.nextElementSibling;)n = (e = e.nextElementSibling).offsetParent; const i = n && n.nodeName; return i && i !== 'BODY' && i !== 'HTML' ? ['TD', 'TABLE'].indexOf(n.nodeName) !== -1 && Pe(n, 'position') === 'static' ? We(n) : n : e ? e.ownerDocument.documentElement : document.documentElement; } function Re(e) { return e.parentNode !== null ? Re(e.parentNode) : e; } function Ue(e, t) { if (!(e && e.nodeType && t && t.nodeType)) return document.documentElement; const n = e.compareDocumentPosition(t) & Node.DOCUMENT_POSITION_FOLLOWING; const i = n ? e : t; const r = n ? t : e; const o = document.createRange(); o.setStart(i, 0), o.setEnd(r, 0); let s; let a; const l = o.commonAncestorContainer; if (e !== l && t !== l || i.contains(r)) return (a = (s = l).nodeName) === 'BODY' || a !== 'HTML' && We(s.firstElementChild) !== s ? We(l) : l; const c = Re(e); return c.host ? Ue(c.host, t) : Ue(e, Re(t).host); } function Be(e) {
    const t = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'top') === 'top' ? 'scrollTop' : 'scrollLeft'; const
      n = e.nodeName; if (n === 'BODY' || n === 'HTML') { const i = e.ownerDocument.documentElement; return (e.ownerDocument.scrollingElement || i)[t]; } return e[t];
  } function qe(e, t) {
    const n = t === 'x' ? 'Left' : 'Top'; const
      i = n === 'Left' ? 'Right' : 'Bottom'; return parseFloat(e[`border${n}Width`], 10) + parseFloat(e[`border${i}Width`], 10);
  } function Ke(e, t, n, i) { return Math.max(t[`offset${e}`], t[`scroll${e}`], n[`client${e}`], n[`offset${e}`], n[`scroll${e}`], Fe(10) ? n[`offset${e}`] + i[`margin${e === 'Height' ? 'Top' : 'Left'}`] + i[`margin${e === 'Height' ? 'Bottom' : 'Right'}`] : 0); } function Qe() { const e = document.body; const t = document.documentElement; const n = Fe(10) && getComputedStyle(t); return { height: Ke('Height', e, t, n), width: Ke('Width', e, t, n) }; } const Ye = (function () { function i(e, t) { for (let n = 0; n < t.length; n++) { const i = t[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, 'value' in i && (i.writable = !0), Object.defineProperty(e, i.key, i); } } return function (e, t, n) { return t && i(e.prototype, t), n && i(e, n), e; }; }()); const Ve = function (e, t, n) {
    return t in e ? Object.defineProperty(e, t, {
      value: n, enumerable: !0, configurable: !0, writable: !0,
    }) : e[t] = n, e;
  }; const ze = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const n = arguments[t]; for (const i in n)Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]); } return e; }; function Ge(e) { return ze({}, e, { right: e.left + e.width, bottom: e.top + e.height }); } function Je(e) {
    let t = {}; try { if (Fe(10)) { t = e.getBoundingClientRect(); const n = Be(e, 'top'); const i = Be(e, 'left'); t.top += n, t.left += i, t.bottom += n, t.right += i; } else t = e.getBoundingClientRect(); } catch (e) {} const r = {
      left: t.left, top: t.top, width: t.right - t.left, height: t.bottom - t.top,
    }; const o = e.nodeName === 'HTML' ? Qe() : {}; const s = o.width || e.clientWidth || r.right - r.left; const a = o.height || e.clientHeight || r.bottom - r.top; let l = e.offsetWidth - s; let c = e.offsetHeight - a; if (l || c) { const u = Pe(e); l -= qe(u, 'x'), c -= qe(u, 'y'), r.width -= l, r.height -= c; } return Ge(r);
  } function Ze(e, t) {
    const n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; const i = Fe(10); const r = t.nodeName === 'HTML'; const o = Je(e); const s = Je(t); const a = je(e); const l = Pe(t); const c = parseFloat(l.borderTopWidth, 10); const u = parseFloat(l.borderLeftWidth, 10); n && t.nodeName === 'HTML' && (s.top = Math.max(s.top, 0), s.left = Math.max(s.left, 0)); let f = Ge({
      top: o.top - s.top - c, left: o.left - s.left - u, width: o.width, height: o.height,
    }); if (f.marginTop = 0, f.marginLeft = 0, !i && r) { const h = parseFloat(l.marginTop, 10); const d = parseFloat(l.marginLeft, 10); f.top -= c - h, f.bottom -= c - h, f.left -= u - d, f.right -= u - d, f.marginTop = h, f.marginLeft = d; } return (i && !n ? t.contains(a) : t === a && a.nodeName !== 'BODY') && (f = (function (e, t) { const n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; const i = Be(t, 'top'); const r = Be(t, 'left'); const o = n ? -1 : 1; return e.top += i * o, e.bottom += i * o, e.left += r * o, e.right += r * o, e; }(f, t))), f;
  } function Xe(e) { if (!e || !e.parentElement || Fe()) return document.documentElement; for (var t = e.parentElement; t && Pe(t, 'transform') === 'none';)t = t.parentElement; return t || document.documentElement; } function $e(e, t, n, i) {
    const r = arguments.length > 4 && void 0 !== arguments[4] && arguments[4]; let o = { top: 0, left: 0 }; const s = r ? Xe(e) : Ue(e, t); if (i === 'viewport') {
      o = (function (e) {
        const t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const n = e.ownerDocument.documentElement; const i = Ze(e, n); const r = Math.max(n.clientWidth, window.innerWidth || 0); const o = Math.max(n.clientHeight, window.innerHeight || 0); const s = t ? 0 : Be(n); const a = t ? 0 : Be(n, 'left'); return Ge({
          top: s - i.top + i.marginTop, left: a - i.left + i.marginLeft, width: r, height: o,
        });
      }(s, r));
    } else { let a = void 0; i === 'scrollParent' ? (a = je(Le(t))).nodeName === 'BODY' && (a = e.ownerDocument.documentElement) : a = i === 'window' ? e.ownerDocument.documentElement : i; const l = Ze(a, s, r); if (a.nodeName !== 'HTML' || (function e(t) { const n = t.nodeName; return n !== 'BODY' && n !== 'HTML' && (Pe(t, 'position') === 'fixed' || e(Le(t))); }(s)))o = l; else { const c = Qe(); const u = c.height; const f = c.width; o.top += l.top - l.marginTop, o.bottom = u + l.top, o.left += l.left - l.marginLeft, o.right = f + l.left; } } return o.left += n, o.top += n, o.right -= n, o.bottom -= n, o;
  } function et(e, t, i, n, r) {
    const o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0; if (e.indexOf('auto') === -1) return e; const s = $e(i, n, o, r); const a = {
      top: { width: s.width, height: t.top - s.top }, right: { width: s.right - t.right, height: s.height }, bottom: { width: s.width, height: s.bottom - t.bottom }, left: { width: t.left - s.left, height: s.height },
    }; const l = Object.keys(a).map((e) => { return ze({ key: e }, a[e], { area: (t = a[e], t.width * t.height) }); let t; }).sort((e, t) => t.area - e.area); const c = l.filter((e) => { const t = e.width; const n = e.height; return t >= i.clientWidth && n >= i.clientHeight; }); const u = c.length > 0 ? c[0].key : l[0].key; const f = e.split('-')[1]; return u + (f ? `-${f}` : '');
  } function tt(e, t, n) { const i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null; return Ze(n, i ? Xe(t) : Ue(t, n), i); } function nt(e) { const t = getComputedStyle(e); const n = parseFloat(t.marginTop) + parseFloat(t.marginBottom); const i = parseFloat(t.marginLeft) + parseFloat(t.marginRight); return { width: e.offsetWidth + i, height: e.offsetHeight + n }; } function it(e) {
    const t = {
      left: 'right', right: 'left', bottom: 'top', top: 'bottom',
    }; return e.replace(/left|right|bottom|top/g, e => t[e]);
  } function rt(e, t, n) { n = n.split('-')[0]; const i = nt(e); const r = { width: i.width, height: i.height }; const o = ['right', 'left'].indexOf(n) !== -1; const s = o ? 'top' : 'left'; const a = o ? 'left' : 'top'; const l = o ? 'height' : 'width'; const c = o ? 'width' : 'height'; return r[s] = t[s] + t[l] / 2 - i[l] / 2, r[a] = n === a ? t[a] - i[c] : t[it(a)], r; } function ot(e, t) { return Array.prototype.find ? e.find(t) : e.filter(t)[0]; } function st(e, n, t) { return (void 0 === t ? e : e.slice(0, (function (e, t, n) { if (Array.prototype.findIndex) return e.findIndex(e => e[t] === n); const i = ot(e, e => e[t] === n); return e.indexOf(i); }(e, 'name', t)))).forEach((e) => { e.function && console.warn('`modifier.function` is deprecated, use `modifier.fn`!'); const t = e.function || e.fn; e.enabled && xe(t) && (n.offsets.popper = Ge(n.offsets.popper), n.offsets.reference = Ge(n.offsets.reference), n = t(n, e)); }), n; } function at(e, n) { return e.some((e) => { const t = e.name; return e.enabled && t === n; }); } function lt(e) { for (let t = [!1, 'ms', 'Webkit', 'Moz', 'O'], n = e.charAt(0).toUpperCase() + e.slice(1), i = 0; i < t.length; i++) { const r = t[i]; const o = r ? `${r}${n}` : e; if (typeof document.body.style[o] !== 'undefined') return o; } return null; } function ct(e) { const t = e.ownerDocument; return t ? t.defaultView : window; } function ut(e, t, n, i) { n.updateBound = i, ct(e).addEventListener('resize', n.updateBound, { passive: !0 }); const r = je(e); return (function e(t, n, i, r) { const o = t.nodeName === 'BODY'; const s = o ? t.ownerDocument.defaultView : t; s.addEventListener(n, i, { passive: !0 }), o || e(je(s.parentNode), n, i, r), r.push(s); }(r, 'scroll', n.updateBound, n.scrollParents)), n.scrollElement = r, n.eventsEnabled = !0, n; } function ft() { let e; let t; this.state.eventsEnabled && (cancelAnimationFrame(this.scheduleUpdate), this.state = (e = this.reference, t = this.state, ct(e).removeEventListener('resize', t.updateBound), t.scrollParents.forEach((e) => { e.removeEventListener('scroll', t.updateBound); }), t.updateBound = null, t.scrollParents = [], t.scrollElement = null, t.eventsEnabled = !1, t)); } function ht(e) { return e !== '' && !isNaN(parseFloat(e)) && isFinite(e); } function dt(n, i) { Object.keys(i).forEach((e) => { let t = ''; ['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(e) !== -1 && ht(i[e]) && (t = 'px'), n.style[e] = i[e] + t; }); } function pt(e, t, n) { const i = ot(e, e => e.name === t); const r = !!i && e.some(e => e.name === n && e.enabled && e.order < i.order); if (!r) { const o = `\`${t}\``; const s = `\`${n}\``; console.warn(`${s} modifier is required by ${o} modifier in order to work, be sure to include it before ${o}!`); } return r; } const mt = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start']; const gt = mt.slice(3); function _t(e) { const t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const n = gt.indexOf(e); const i = gt.slice(n + 1).concat(gt.slice(0, n)); return t ? i.reverse() : i; } const vt = 'flip'; const yt = 'clockwise'; const Et = 'counterclockwise'; function bt(e, r, o, t) {
    const s = [0, 0]; const a = ['right', 'left'].indexOf(t) !== -1; const n = e.split(/(\+|\-)/).map(e => e.trim()); const i = n.indexOf(ot(n, e => e.search(/,|\s/) !== -1)); n[i] && n[i].indexOf(',') === -1 && console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.'); const l = /\s*,\s*|\s+/; let c = i !== -1 ? [n.slice(0, i).concat([n[i].split(l)[0]]), [n[i].split(l)[1]].concat(n.slice(i + 1))] : [n]; return (c = c.map((e, t) => {
      const n = (t === 1 ? !a : a) ? 'height' : 'width'; let
        i = !1; return e.reduce((e, t) => (e[e.length - 1] === '' && ['+', '-'].indexOf(t) !== -1 ? (e[e.length - 1] = t, i = !0, e) : i ? (e[e.length - 1] += t, i = !1, e) : e.concat(t)), []).map(e => (function (e, t, n, i) { const r = e.match(/((?:\-|\+)?\d*\.?\d*)(.*)/); const o = +r[1]; const s = r[2]; if (!o) return e; if (s.indexOf('%') === 0) { let a = void 0; switch (s) { case '%p': a = n; break; case '%': case '%r': default: a = i; } return Ge(a)[t] / 100 * o; } if (s === 'vh' || s === 'vw') return (s === 'vh' ? Math.max(document.documentElement.clientHeight, window.innerHeight || 0) : Math.max(document.documentElement.clientWidth, window.innerWidth || 0)) / 100 * o; return o; }(e, n, r, o)));
    })).forEach((n, i) => { n.forEach((e, t) => { ht(e) && (s[i] += e * (n[t - 1] === '-' ? -1 : 1)); }); }), s;
  } const wt = {
    placement: 'bottom',
    positionFixed: !1,
    eventsEnabled: !0,
    removeOnDestroy: !1,
    onCreate() {},
    onUpdate() {},
    modifiers: {
      shift: { order: 100, enabled: !0, fn(e) { const t = e.placement; const n = t.split('-')[0]; const i = t.split('-')[1]; if (i) { const r = e.offsets; const o = r.reference; const s = r.popper; const a = ['bottom', 'top'].indexOf(n) !== -1; const l = a ? 'left' : 'top'; const c = a ? 'width' : 'height'; const u = { start: Ve({}, l, o[l]), end: Ve({}, l, o[l] + o[c] - s[c]) }; e.offsets.popper = ze({}, s, u[i]); } return e; } },
      offset: {
        order: 200, enabled: !0, fn(e, t) { const n = t.offset; const i = e.placement; const r = e.offsets; const o = r.popper; const s = r.reference; const a = i.split('-')[0]; let l = void 0; return l = ht(+n) ? [+n, 0] : bt(n, o, s, a), a === 'left' ? (o.top += l[0], o.left -= l[1]) : a === 'right' ? (o.top += l[0], o.left += l[1]) : a === 'top' ? (o.left += l[0], o.top -= l[1]) : a === 'bottom' && (o.left += l[0], o.top += l[1]), e.popper = o, e; }, offset: 0,
      },
      preventOverflow: {
        order: 300,
        enabled: !0,
        fn(e, i) {
          let t = i.boundariesElement || We(e.instance.popper); e.instance.reference === t && (t = We(t)); const n = lt('transform'); const r = e.instance.popper.style; const o = r.top; const s = r.left; const a = r[n]; r.top = '', r.left = '', r[n] = ''; const l = $e(e.instance.popper, e.instance.reference, i.padding, t, e.positionFixed); r.top = o, r.left = s, r[n] = a, i.boundaries = l; const c = i.priority; let u = e.offsets.popper; const f = {
            primary(e) { let t = u[e]; return u[e] < l[e] && !i.escapeWithReference && (t = Math.max(u[e], l[e])), Ve({}, e, t); },
            secondary(e) {
              const t = e === 'right' ? 'left' : 'top'; let
                n = u[t]; return u[e] > l[e] && !i.escapeWithReference && (n = Math.min(u[t], l[e] - (e === 'right' ? u.width : u.height))), Ve({}, t, n);
            },
          }; return c.forEach((e) => { const t = ['left', 'top'].indexOf(e) !== -1 ? 'primary' : 'secondary'; u = ze({}, u, f[t](e)); }), e.offsets.popper = u, e;
        },
        priority: ['left', 'right', 'top', 'bottom'],
        padding: 5,
        boundariesElement: 'scrollParent',
      },
      keepTogether: { order: 400, enabled: !0, fn(e) { const t = e.offsets; const n = t.popper; const i = t.reference; const r = e.placement.split('-')[0]; const o = Math.floor; const s = ['top', 'bottom'].indexOf(r) !== -1; const a = s ? 'right' : 'bottom'; const l = s ? 'left' : 'top'; const c = s ? 'width' : 'height'; return n[a] < o(i[l]) && (e.offsets.popper[l] = o(i[l]) - n[c]), n[l] > o(i[a]) && (e.offsets.popper[l] = o(i[a])), e; } },
      arrow: {
        order: 500, enabled: !0, fn(e, t) { let n; if (!pt(e.instance.modifiers, 'arrow', 'keepTogether')) return e; let i = t.element; if (typeof i === 'string') { if (!(i = e.instance.popper.querySelector(i))) return e; } else if (!e.instance.popper.contains(i)) return console.warn('WARNING: `arrow.element` must be child of its popper element!'), e; const r = e.placement.split('-')[0]; const o = e.offsets; const s = o.popper; const a = o.reference; const l = ['left', 'right'].indexOf(r) !== -1; const c = l ? 'height' : 'width'; const u = l ? 'Top' : 'Left'; const f = u.toLowerCase(); const h = l ? 'left' : 'top'; const d = l ? 'bottom' : 'right'; const p = nt(i)[c]; a[d] - p < s[f] && (e.offsets.popper[f] -= s[f] - (a[d] - p)), a[f] + p > s[d] && (e.offsets.popper[f] += a[f] + p - s[d]), e.offsets.popper = Ge(e.offsets.popper); const m = a[f] + a[c] / 2 - p / 2; const g = Pe(e.instance.popper); const _ = parseFloat(g[`margin${u}`], 10); const v = parseFloat(g[`border${u}Width`], 10); let y = m - e.offsets.popper[f] - _ - v; return y = Math.max(Math.min(s[c] - p, y), 0), e.arrowElement = i, e.offsets.arrow = (Ve(n = {}, f, Math.round(y)), Ve(n, h, ''), n), e; }, element: '[x-arrow]',
      },
      flip: {
        order: 600, enabled: !0, fn(p, m) { if (at(p.instance.modifiers, 'inner')) return p; if (p.flipped && p.placement === p.originalPlacement) return p; const g = $e(p.instance.popper, p.instance.reference, m.padding, m.boundariesElement, p.positionFixed); let _ = p.placement.split('-')[0]; let v = it(_); let y = p.placement.split('-')[1] || ''; let E = []; switch (m.behavior) { case vt: E = [_, v]; break; case yt: E = _t(_); break; case Et: E = _t(_, !0); break; default: E = m.behavior; } return E.forEach((e, t) => { if (_ !== e || E.length === t + 1) return p; _ = p.placement.split('-')[0], v = it(_); let n; const i = p.offsets.popper; const r = p.offsets.reference; const o = Math.floor; const s = _ === 'left' && o(i.right) > o(r.left) || _ === 'right' && o(i.left) < o(r.right) || _ === 'top' && o(i.bottom) > o(r.top) || _ === 'bottom' && o(i.top) < o(r.bottom); const a = o(i.left) < o(g.left); const l = o(i.right) > o(g.right); const c = o(i.top) < o(g.top); const u = o(i.bottom) > o(g.bottom); const f = _ === 'left' && a || _ === 'right' && l || _ === 'top' && c || _ === 'bottom' && u; const h = ['top', 'bottom'].indexOf(_) !== -1; const d = !!m.flipVariations && (h && y === 'start' && a || h && y === 'end' && l || !h && y === 'start' && c || !h && y === 'end' && u); (s || f || d) && (p.flipped = !0, (s || f) && (_ = E[t + 1]), d && (y = (n = y) === 'end' ? 'start' : n === 'start' ? 'end' : n), p.placement = _ + (y ? `-${y}` : ''), p.offsets.popper = ze({}, p.offsets.popper, rt(p.instance.popper, p.offsets.reference, p.placement)), p = st(p.instance.modifiers, p, 'flip')); }), p; }, behavior: 'flip', padding: 5, boundariesElement: 'viewport',
      },
      inner: { order: 700, enabled: !1, fn(e) { const t = e.placement; const n = t.split('-')[0]; const i = e.offsets; const r = i.popper; const o = i.reference; const s = ['left', 'right'].indexOf(n) !== -1; const a = ['top', 'left'].indexOf(n) === -1; return r[s ? 'left' : 'top'] = o[n] - (a ? r[s ? 'width' : 'height'] : 0), e.placement = it(t), e.offsets.popper = Ge(r), e; } },
      hide: { order: 800, enabled: !0, fn(e) { if (!pt(e.instance.modifiers, 'hide', 'preventOverflow')) return e; const t = e.offsets.reference; const n = ot(e.instance.modifiers, e => e.name === 'preventOverflow').boundaries; if (t.bottom < n.top || t.left > n.right || t.top > n.bottom || t.right < n.left) { if (!0 === e.hide) return e; e.hide = !0, e.attributes['x-out-of-boundaries'] = ''; } else { if (!1 === e.hide) return e; e.hide = !1, e.attributes['x-out-of-boundaries'] = !1; } return e; } },
      computeStyle: {
        order: 850,
        enabled: !0,
        fn(e, t) {
          const n = t.x; const i = t.y; const r = e.offsets.popper; const o = ot(e.instance.modifiers, e => e.name === 'applyStyle').gpuAcceleration; void 0 !== o && console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!'); const s = void 0 !== o ? o : t.gpuAcceleration; const a = Je(We(e.instance.popper)); const l = { position: r.position }; const c = {
            left: Math.floor(r.left), top: Math.round(r.top), bottom: Math.round(r.bottom), right: Math.floor(r.right),
          }; const u = n === 'bottom' ? 'top' : 'bottom'; const f = i === 'right' ? 'left' : 'right'; const h = lt('transform'); let d = void 0; let p = void 0; if (p = u === 'bottom' ? -a.height + c.bottom : c.top, d = f === 'right' ? -a.width + c.right : c.left, s && h)l[h] = `translate3d(${d}px, ${p}px, 0)`, l[u] = 0, l[f] = 0, l.willChange = 'transform'; else { const m = u === 'bottom' ? -1 : 1; const g = f === 'right' ? -1 : 1; l[u] = p * m, l[f] = d * g, l.willChange = `${u}, ${f}`; } const _ = { 'x-placement': e.placement }; return e.attributes = ze({}, _, e.attributes), e.styles = ze({}, l, e.styles), e.arrowStyles = ze({}, e.offsets.arrow, e.arrowStyles), e;
        },
        gpuAcceleration: !0,
        x: 'bottom',
        y: 'right',
      },
      applyStyle: {
        order: 900, enabled: !0, fn(e) { let t; let n; return dt(e.instance.popper, e.styles), t = e.instance.popper, n = e.attributes, Object.keys(n).forEach((e) => { !1 !== n[e] ? t.setAttribute(e, n[e]) : t.removeAttribute(e); }), e.arrowElement && Object.keys(e.arrowStyles).length && dt(e.arrowElement, e.arrowStyles), e; }, onLoad(e, t, n, i, r) { const o = tt(r, t, e, n.positionFixed); const s = et(n.placement, o, t, e, n.modifiers.flip.boundariesElement, n.modifiers.flip.padding); return t.setAttribute('x-placement', s), dt(t, { position: n.positionFixed ? 'fixed' : 'absolute' }), n; }, gpuAcceleration: void 0,
      },
    },
  }; const Ct = (function () {
    function o(e, t) { const n = this; const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; !(function (e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); }(this, o)), this.scheduleUpdate = function () { return requestAnimationFrame(n.update); }, this.update = ke(this.update.bind(this)), this.options = ze({}, o.Defaults, i), this.state = { isDestroyed: !1, isCreated: !1, scrollParents: [] }, this.reference = e && e.jquery ? e[0] : e, this.popper = t && t.jquery ? t[0] : t, this.options.modifiers = {}, Object.keys(ze({}, o.Defaults.modifiers, i.modifiers)).forEach((e) => { n.options.modifiers[e] = ze({}, o.Defaults.modifiers[e] || {}, i.modifiers ? i.modifiers[e] : {}); }), this.modifiers = Object.keys(this.options.modifiers).map(e => ze({ name: e }, n.options.modifiers[e])).sort((e, t) => e.order - t.order), this.modifiers.forEach((e) => { e.enabled && xe(e.onLoad) && e.onLoad(n.reference, n.popper, n.options, e, n.state); }), this.update(); const r = this.options.eventsEnabled; r && this.enableEventListeners(), this.state.eventsEnabled = r; } return Ye(o, [{
      key: 'update',
      value() {
        return function () {
          if (!this.state.isDestroyed) {
            let e = {
              instance: this, styles: {}, arrowStyles: {}, attributes: {}, flipped: !1, offsets: {},
            }; e.offsets.reference = tt(this.state, this.popper, this.reference, this.options.positionFixed), e.placement = et(this.options.placement, e.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding), e.originalPlacement = e.placement, e.positionFixed = this.options.positionFixed, e.offsets.popper = rt(this.popper, e.offsets.reference, e.placement), e.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute', e = st(this.modifiers, e), this.state.isCreated ? this.options.onUpdate(e) : (this.state.isCreated = !0, this.options.onCreate(e));
          }
        }.call(this);
      },
    }, { key: 'destroy', value() { return function () { return this.state.isDestroyed = !0, at(this.modifiers, 'applyStyle') && (this.popper.removeAttribute('x-placement'), this.popper.style.position = '', this.popper.style.top = '', this.popper.style.left = '', this.popper.style.right = '', this.popper.style.bottom = '', this.popper.style.willChange = '', this.popper.style[lt('transform')] = ''), this.disableEventListeners(), this.options.removeOnDestroy && this.popper.parentNode.removeChild(this.popper), this; }.call(this); } }, { key: 'enableEventListeners', value() { return function () { this.state.eventsEnabled || (this.state = ut(this.reference, this.options, this.state, this.scheduleUpdate)); }.call(this); } }, { key: 'disableEventListeners', value() { return ft.call(this); } }]), o;
  }()); Ct.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils, Ct.placements = mt, Ct.Defaults = wt; let Tt; let St; let Dt; let At; let It; let Ot; let Nt; let kt; let xt; let Pt; let Lt; let jt; let Ht; let Mt; let Ft; let Wt; let Rt; let Ut; let Bt; let qt; let Kt; let Qt; let Yt; let Vt; let zt; let Gt; let Jt; let Zt; let Xt; let $t; let en; let tn; let nn; let rn; let on; let sn; let an; let ln; let cn; let un; let fn; let hn; let dn; let pn; let mn; let gn; let _n; let vn; let yn; let En; let bn; let wn; let Cn; let Tn; let Sn; let Dn; let An; let In; let On; let Nn; let kn; let xn; let Pn; let Ln; let jn; let Hn; let Mn; let Fn; let Wn; let Rn; let Un; let Bn; let qn; let Kn; let Qn; let Yn; let Vn; let zn; let Gn; let Jn; let Zn; let Xn; let $n; let ei; let ti; let ni; let ii; let ri; let oi; let si; let ai; let li; let ci; let ui; let fi; let hi; let di; let pi; let mi; let gi; let _i; let vi; let yi; let Ei; let bi; let wi; let Ci; let Ti; let Si; let Di; let Ai; let Ii; let Oi; let Ni; let ki; let xi; let Pi; let Li; let ji; let Hi; let Mi; let Fi; let Wi; let Ri; let Ui; const Bi = (St = 'dropdown', At = `.${Dt = 'bs.dropdown'}`, It = '.data-api', Ot = (Tt = t).fn[St], Nt = new RegExp('38|40|27'), kt = {
    HIDE: `hide${At}`, HIDDEN: `hidden${At}`, SHOW: `show${At}`, SHOWN: `shown${At}`, CLICK: `click${At}`, CLICK_DATA_API: `click${At}${It}`, KEYDOWN_DATA_API: `keydown${At}${It}`, KEYUP_DATA_API: `keyup${At}${It}`,
  }, xt = 'disabled', Pt = 'show', Lt = 'dropup', jt = 'dropright', Ht = 'dropleft', Mt = 'dropdown-menu-right', Ft = 'position-static', Wt = '[data-toggle="dropdown"]', Rt = '.dropdown form', Ut = '.dropdown-menu', Bt = '.navbar-nav', qt = '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)', Kt = 'top-start', Qt = 'top-end', Yt = 'bottom-start', Vt = 'bottom-end', zt = 'right-start', Gt = 'left-start', Jt = {
    offset: 0, flip: !0, boundary: 'scrollParent', reference: 'toggle', display: 'dynamic',
  }, Zt = {
    offset: '(number|string|function)', flip: 'boolean', boundary: '(string|element)', reference: '(string|element)', display: 'string',
  }, Xt = (function () { function c(e, t) { this._element = e, this._popper = null, this._config = this._getConfig(t), this._menu = this._getMenuElement(), this._inNavbar = this._detectNavbar(), this._addEventListeners(); } const e = c.prototype; return e.toggle = function () { if (!this._element.disabled && !Tt(this._element).hasClass(xt)) { const e = c._getParentFromElement(this._element); const t = Tt(this._menu).hasClass(Pt); if (c._clearMenus(), !t) { const n = { relatedTarget: this._element }; const i = Tt.Event(kt.SHOW, n); if (Tt(e).trigger(i), !i.isDefaultPrevented()) { if (!this._inNavbar) { if (typeof Ct === 'undefined') throw new TypeError('Bootstrap dropdown require Popper.js (https://popper.js.org)'); let r = this._element; this._config.reference === 'parent' ? r = e : we.isElement(this._config.reference) && (r = this._config.reference, typeof this._config.reference.jquery !== 'undefined' && (r = this._config.reference[0])), this._config.boundary !== 'scrollParent' && Tt(e).addClass(Ft), this._popper = new Ct(r, this._menu, this._getPopperConfig()); }'ontouchstart' in document.documentElement && Tt(e).closest(Bt).length === 0 && Tt(document.body).children().on('mouseover', null, Tt.noop), this._element.focus(), this._element.setAttribute('aria-expanded', !0), Tt(this._menu).toggleClass(Pt), Tt(e).toggleClass(Pt).trigger(Tt.Event(kt.SHOWN, n)); } } } }, e.dispose = function () { Tt.removeData(this._element, Dt), Tt(this._element).off(At), this._element = null, (this._menu = null) !== this._popper && (this._popper.destroy(), this._popper = null); }, e.update = function () { this._inNavbar = this._detectNavbar(), this._popper !== null && this._popper.scheduleUpdate(); }, e._addEventListeners = function () { const t = this; Tt(this._element).on(kt.CLICK, (e) => { e.preventDefault(), e.stopPropagation(), t.toggle(); }); }, e._getConfig = function (e) { return e = l({}, this.constructor.Default, Tt(this._element).data(), e), we.typeCheckConfig(St, e, this.constructor.DefaultType), e; }, e._getMenuElement = function () { if (!this._menu) { const e = c._getParentFromElement(this._element); e && (this._menu = e.querySelector(Ut)); } return this._menu; }, e._getPlacement = function () { const e = Tt(this._element.parentNode); let t = Yt; return e.hasClass(Lt) ? (t = Kt, Tt(this._menu).hasClass(Mt) && (t = Qt)) : e.hasClass(jt) ? t = zt : e.hasClass(Ht) ? t = Gt : Tt(this._menu).hasClass(Mt) && (t = Vt), t; }, e._detectNavbar = function () { return Tt(this._element).closest('.navbar').length > 0; }, e._getPopperConfig = function () { const t = this; const e = {}; typeof this._config.offset === 'function' ? e.fn = function (e) { return e.offsets = l({}, e.offsets, t._config.offset(e.offsets) || {}), e; } : e.offset = this._config.offset; const n = { placement: this._getPlacement(), modifiers: { offset: e, flip: { enabled: this._config.flip }, preventOverflow: { boundariesElement: this._config.boundary } } }; return this._config.display === 'static' && (n.modifiers.applyStyle = { enabled: !1 }), n; }, c._jQueryInterface = function (t) { return this.each(function () { let e = Tt(this).data(Dt); if (e || (e = new c(this, typeof t === 'object' ? t : null), Tt(this).data(Dt, e)), typeof t === 'string') { if (typeof e[t] === 'undefined') throw new TypeError(`No method named "${t}"`); e[t](); } }); }, c._clearMenus = function (e) { if (!e || e.which !== 3 && (e.type !== 'keyup' || e.which === 9)) for (let t = [].slice.call(document.querySelectorAll(Wt)), n = 0, i = t.length; n < i; n++) { const r = c._getParentFromElement(t[n]); const o = Tt(t[n]).data(Dt); const s = { relatedTarget: t[n] }; if (e && e.type === 'click' && (s.clickEvent = e), o) { const a = o._menu; if (Tt(r).hasClass(Pt) && !(e && (e.type === 'click' && /input|textarea/i.test(e.target.tagName) || e.type === 'keyup' && e.which === 9) && Tt.contains(r, e.target))) { const l = Tt.Event(kt.HIDE, s); Tt(r).trigger(l), l.isDefaultPrevented() || ('ontouchstart' in document.documentElement && Tt(document.body).children().off('mouseover', null, Tt.noop), t[n].setAttribute('aria-expanded', 'false'), Tt(a).removeClass(Pt), Tt(r).removeClass(Pt).trigger(Tt.Event(kt.HIDDEN, s))); } } } }, c._getParentFromElement = function (e) { let t; const n = we.getSelectorFromElement(e); return n && (t = document.querySelector(n)), t || e.parentNode; }, c._dataApiKeydownHandler = function (e) { if ((/input|textarea/i.test(e.target.tagName) ? !(e.which === 32 || e.which !== 27 && (e.which !== 40 && e.which !== 38 || Tt(e.target).closest(Ut).length)) : Nt.test(e.which)) && (e.preventDefault(), e.stopPropagation(), !this.disabled && !Tt(this).hasClass(xt))) { const t = c._getParentFromElement(this); const n = Tt(t).hasClass(Pt); if ((n || e.which === 27 && e.which === 32) && (!n || e.which !== 27 && e.which !== 32)) { const i = [].slice.call(t.querySelectorAll(qt)); if (i.length !== 0) { let r = i.indexOf(e.target); e.which === 38 && r > 0 && r--, e.which === 40 && r < i.length - 1 && r++, r < 0 && (r = 0), i[r].focus(); } } else { if (e.which === 27) { const o = t.querySelector(Wt); Tt(o).trigger('focus'); }Tt(this).trigger('click'); } } }, s(c, null, [{ key: 'VERSION', get() { return '4.1.3'; } }, { key: 'Default', get() { return Jt; } }, { key: 'DefaultType', get() { return Zt; } }]), c; }()), Tt(document).on(kt.KEYDOWN_DATA_API, Wt, Xt._dataApiKeydownHandler).on(kt.KEYDOWN_DATA_API, Ut, Xt._dataApiKeydownHandler).on(`${kt.CLICK_DATA_API} ${kt.KEYUP_DATA_API}`, Xt._clearMenus)
    .on(kt.CLICK_DATA_API, Wt, function (e) { e.preventDefault(), e.stopPropagation(), Xt._jQueryInterface.call(Tt(this), 'toggle'); })
    .on(kt.CLICK_DATA_API, Rt, (e) => { e.stopPropagation(); }), Tt.fn[St] = Xt._jQueryInterface, Tt.fn[St].Constructor = Xt, Tt.fn[St].noConflict = function () { return Tt.fn[St] = Ot, Xt._jQueryInterface; }, Xt); const qi = (en = 'modal', nn = `.${tn = 'bs.modal'}`, rn = ($t = t).fn[en], on = {
    backdrop: !0, keyboard: !0, focus: !0, show: !0,
  }, sn = {
    backdrop: '(boolean|string)', keyboard: 'boolean', focus: 'boolean', show: 'boolean',
  }, an = {
    HIDE: `hide${nn}`, HIDDEN: `hidden${nn}`, SHOW: `show${nn}`, SHOWN: `shown${nn}`, FOCUSIN: `focusin${nn}`, RESIZE: `resize${nn}`, CLICK_DISMISS: `click.dismiss${nn}`, KEYDOWN_DISMISS: `keydown.dismiss${nn}`, MOUSEUP_DISMISS: `mouseup.dismiss${nn}`, MOUSEDOWN_DISMISS: `mousedown.dismiss${nn}`, CLICK_DATA_API: `click${nn}.data-api`,
  }, ln = 'modal-scrollbar-measure', cn = 'modal-backdrop', un = 'modal-open', fn = 'fade', hn = 'show', dn = '.modal-dialog', pn = '[data-toggle="modal"]', mn = '[data-dismiss="modal"]', gn = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top', _n = '.sticky-top', vn = (function () { function r(e, t) { this._config = this._getConfig(t), this._element = e, this._dialog = e.querySelector(dn), this._backdrop = null, this._isShown = !1, this._isBodyOverflowing = !1, this._ignoreBackdropClick = !1, this._scrollbarWidth = 0; } const e = r.prototype; return e.toggle = function (e) { return this._isShown ? this.hide() : this.show(e); }, e.show = function (e) { const t = this; if (!this._isTransitioning && !this._isShown) { $t(this._element).hasClass(fn) && (this._isTransitioning = !0); const n = $t.Event(an.SHOW, { relatedTarget: e }); $t(this._element).trigger(n), this._isShown || n.isDefaultPrevented() || (this._isShown = !0, this._checkScrollbar(), this._setScrollbar(), this._adjustDialog(), $t(document.body).addClass(un), this._setEscapeEvent(), this._setResizeEvent(), $t(this._element).on(an.CLICK_DISMISS, mn, e => t.hide(e)), $t(this._dialog).on(an.MOUSEDOWN_DISMISS, () => { $t(t._element).one(an.MOUSEUP_DISMISS, (e) => { $t(e.target).is(t._element) && (t._ignoreBackdropClick = !0); }); }), this._showBackdrop(() => t._showElement(e))); } }, e.hide = function (e) { const t = this; if (e && e.preventDefault(), !this._isTransitioning && this._isShown) { const n = $t.Event(an.HIDE); if ($t(this._element).trigger(n), this._isShown && !n.isDefaultPrevented()) { this._isShown = !1; const i = $t(this._element).hasClass(fn); if (i && (this._isTransitioning = !0), this._setEscapeEvent(), this._setResizeEvent(), $t(document).off(an.FOCUSIN), $t(this._element).removeClass(hn), $t(this._element).off(an.CLICK_DISMISS), $t(this._dialog).off(an.MOUSEDOWN_DISMISS), i) { const r = we.getTransitionDurationFromElement(this._element); $t(this._element).one(we.TRANSITION_END, e => t._hideModal(e)).emulateTransitionEnd(r); } else this._hideModal(); } } }, e.dispose = function () { $t.removeData(this._element, tn), $t(window, document, this._element, this._backdrop).off(nn), this._config = null, this._element = null, this._dialog = null, this._backdrop = null, this._isShown = null, this._isBodyOverflowing = null, this._ignoreBackdropClick = null, this._scrollbarWidth = null; }, e.handleUpdate = function () { this._adjustDialog(); }, e._getConfig = function (e) { return e = l({}, on, e), we.typeCheckConfig(en, e, sn), e; }, e._showElement = function (e) { const t = this; const n = $t(this._element).hasClass(fn); this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE || document.body.appendChild(this._element), this._element.style.display = 'block', this._element.removeAttribute('aria-hidden'), this._element.scrollTop = 0, n && we.reflow(this._element), $t(this._element).addClass(hn), this._config.focus && this._enforceFocus(); const i = $t.Event(an.SHOWN, { relatedTarget: e }); const r = function () { t._config.focus && t._element.focus(), t._isTransitioning = !1, $t(t._element).trigger(i); }; if (n) { const o = we.getTransitionDurationFromElement(this._element); $t(this._dialog).one(we.TRANSITION_END, r).emulateTransitionEnd(o); } else r(); }, e._enforceFocus = function () { const t = this; $t(document).off(an.FOCUSIN).on(an.FOCUSIN, (e) => { document !== e.target && t._element !== e.target && $t(t._element).has(e.target).length === 0 && t._element.focus(); }); }, e._setEscapeEvent = function () { const t = this; this._isShown && this._config.keyboard ? $t(this._element).on(an.KEYDOWN_DISMISS, (e) => { e.which === 27 && (e.preventDefault(), t.hide()); }) : this._isShown || $t(this._element).off(an.KEYDOWN_DISMISS); }, e._setResizeEvent = function () { const t = this; this._isShown ? $t(window).on(an.RESIZE, e => t.handleUpdate(e)) : $t(window).off(an.RESIZE); }, e._hideModal = function () { const e = this; this._element.style.display = 'none', this._element.setAttribute('aria-hidden', !0), this._isTransitioning = !1, this._showBackdrop(() => { $t(document.body).removeClass(un), e._resetAdjustments(), e._resetScrollbar(), $t(e._element).trigger(an.HIDDEN); }); }, e._removeBackdrop = function () { this._backdrop && ($t(this._backdrop).remove(), this._backdrop = null); }, e._showBackdrop = function (e) { const t = this; const n = $t(this._element).hasClass(fn) ? fn : ''; if (this._isShown && this._config.backdrop) { if (this._backdrop = document.createElement('div'), this._backdrop.className = cn, n && this._backdrop.classList.add(n), $t(this._backdrop).appendTo(document.body), $t(this._element).on(an.CLICK_DISMISS, (e) => { t._ignoreBackdropClick ? t._ignoreBackdropClick = !1 : e.target === e.currentTarget && (t._config.backdrop === 'static' ? t._element.focus() : t.hide()); }), n && we.reflow(this._backdrop), $t(this._backdrop).addClass(hn), !e) return; if (!n) return void e(); const i = we.getTransitionDurationFromElement(this._backdrop); $t(this._backdrop).one(we.TRANSITION_END, e).emulateTransitionEnd(i); } else if (!this._isShown && this._backdrop) { $t(this._backdrop).removeClass(hn); const r = function () { t._removeBackdrop(), e && e(); }; if ($t(this._element).hasClass(fn)) { const o = we.getTransitionDurationFromElement(this._backdrop); $t(this._backdrop).one(we.TRANSITION_END, r).emulateTransitionEnd(o); } else r(); } else e && e(); }, e._adjustDialog = function () { const e = this._element.scrollHeight > document.documentElement.clientHeight; !this._isBodyOverflowing && e && (this._element.style.paddingLeft = `${this._scrollbarWidth}px`), this._isBodyOverflowing && !e && (this._element.style.paddingRight = `${this._scrollbarWidth}px`); }, e._resetAdjustments = function () { this._element.style.paddingLeft = '', this._element.style.paddingRight = ''; }, e._checkScrollbar = function () { const e = document.body.getBoundingClientRect(); this._isBodyOverflowing = e.left + e.right < window.innerWidth, this._scrollbarWidth = this._getScrollbarWidth(); }, e._setScrollbar = function () { const r = this; if (this._isBodyOverflowing) { const e = [].slice.call(document.querySelectorAll(gn)); const t = [].slice.call(document.querySelectorAll(_n)); $t(e).each((e, t) => { const n = t.style.paddingRight; const i = $t(t).css('padding-right'); $t(t).data('padding-right', n).css('padding-right', `${parseFloat(i) + r._scrollbarWidth}px`); }), $t(t).each((e, t) => { const n = t.style.marginRight; const i = $t(t).css('margin-right'); $t(t).data('margin-right', n).css('margin-right', `${parseFloat(i) - r._scrollbarWidth}px`); }); const n = document.body.style.paddingRight; const i = $t(document.body).css('padding-right'); $t(document.body).data('padding-right', n).css('padding-right', `${parseFloat(i) + this._scrollbarWidth}px`); } }, e._resetScrollbar = function () { const e = [].slice.call(document.querySelectorAll(gn)); $t(e).each((e, t) => { const n = $t(t).data('padding-right'); $t(t).removeData('padding-right'), t.style.paddingRight = n || ''; }); const t = [].slice.call(document.querySelectorAll(`${_n}`)); $t(t).each((e, t) => { const n = $t(t).data('margin-right'); typeof n !== 'undefined' && $t(t).css('margin-right', n).removeData('margin-right'); }); const n = $t(document.body).data('padding-right'); $t(document.body).removeData('padding-right'), document.body.style.paddingRight = n || ''; }, e._getScrollbarWidth = function () { const e = document.createElement('div'); e.className = ln, document.body.appendChild(e); const t = e.getBoundingClientRect().width - e.clientWidth; return document.body.removeChild(e), t; }, r._jQueryInterface = function (n, i) { return this.each(function () { let e = $t(this).data(tn); const t = l({}, on, $t(this).data(), typeof n === 'object' && n ? n : {}); if (e || (e = new r(this, t), $t(this).data(tn, e)), typeof n === 'string') { if (typeof e[n] === 'undefined') throw new TypeError(`No method named "${n}"`); e[n](i); } else t.show && e.show(i); }); }, s(r, null, [{ key: 'VERSION', get() { return '4.1.3'; } }, { key: 'Default', get() { return on; } }]), r; }()), $t(document).on(an.CLICK_DATA_API, pn, function (e) { let t; const n = this; const i = we.getSelectorFromElement(this); i && (t = document.querySelector(i)); const r = $t(t).data(tn) ? 'toggle' : l({}, $t(t).data(), $t(this).data()); this.tagName !== 'A' && this.tagName !== 'AREA' || e.preventDefault(); var o = $t(t).one(an.SHOW, (e) => { e.isDefaultPrevented() || o.one(an.HIDDEN, () => { $t(n).is(':visible') && n.focus(); }); }); vn._jQueryInterface.call($t(t), r, this); }), $t.fn[en] = vn._jQueryInterface, $t.fn[en].Constructor = vn, $t.fn[en].noConflict = function () { return $t.fn[en] = rn, vn._jQueryInterface; }, vn); const Ki = (En = 'tooltip', wn = `.${bn = 'bs.tooltip'}`, Cn = (yn = t).fn[En], Tn = 'bs-tooltip', Sn = new RegExp(`(^|\\s)${Tn}\\S+`, 'g'), In = {
    animation: !0,
    template: '<div class="tooltip" role="tooltip"><div class="arrow"></div><div class="tooltip-inner"></div></div>',
    trigger: 'hover focus',
    title: '',
    delay: 0,
    html: !(An = {
      AUTO: 'auto', TOP: 'top', RIGHT: 'right', BOTTOM: 'bottom', LEFT: 'left',
    }),
    selector: !(Dn = {
      animation: 'boolean', template: 'string', title: '(string|element|function)', trigger: 'string', delay: '(number|object)', html: 'boolean', selector: '(string|boolean)', placement: '(string|function)', offset: '(number|string)', container: '(string|element|boolean)', fallbackPlacement: '(string|array)', boundary: '(string|element)',
    }),
    placement: 'top',
    offset: 0,
    container: !1,
    fallbackPlacement: 'flip',
    boundary: 'scrollParent',
  }, Nn = 'out', kn = {
    HIDE: `hide${wn}`, HIDDEN: `hidden${wn}`, SHOW: (On = 'show') + wn, SHOWN: `shown${wn}`, INSERTED: `inserted${wn}`, CLICK: `click${wn}`, FOCUSIN: `focusin${wn}`, FOCUSOUT: `focusout${wn}`, MOUSEENTER: `mouseenter${wn}`, MOUSELEAVE: `mouseleave${wn}`,
  }, xn = 'fade', Pn = 'show', Ln = '.tooltip-inner', jn = '.arrow', Hn = 'hover', Mn = 'focus', Fn = 'click', Wn = 'manual', Rn = (function () {
    function i(e, t) { if (typeof Ct === 'undefined') throw new TypeError('Bootstrap tooltips require Popper.js (https://popper.js.org)'); this._isEnabled = !0, this._timeout = 0, this._hoverState = '', this._activeTrigger = {}, this._popper = null, this.element = e, this.config = this._getConfig(t), this.tip = null, this._setListeners(); } const e = i.prototype; return e.enable = function () { this._isEnabled = !0; }, e.disable = function () { this._isEnabled = !1; }, e.toggleEnabled = function () { this._isEnabled = !this._isEnabled; }, e.toggle = function (e) { if (this._isEnabled) if (e) { const t = this.constructor.DATA_KEY; let n = yn(e.currentTarget).data(t); n || (n = new this.constructor(e.currentTarget, this._getDelegateConfig()), yn(e.currentTarget).data(t, n)), n._activeTrigger.click = !n._activeTrigger.click, n._isWithActiveTrigger() ? n._enter(null, n) : n._leave(null, n); } else { if (yn(this.getTipElement()).hasClass(Pn)) return void this._leave(null, this); this._enter(null, this); } }, e.dispose = function () { clearTimeout(this._timeout), yn.removeData(this.element, this.constructor.DATA_KEY), yn(this.element).off(this.constructor.EVENT_KEY), yn(this.element).closest('.modal').off('hide.bs.modal'), this.tip && yn(this.tip).remove(), this._isEnabled = null, this._timeout = null, this._hoverState = null, (this._activeTrigger = null) !== this._popper && this._popper.destroy(), this._popper = null, this.element = null, this.config = null, this.tip = null; }, e.show = function () {
      const t = this; if (yn(this.element).css('display') === 'none') throw new Error('Please use show on visible elements'); const e = yn.Event(this.constructor.Event.SHOW); if (this.isWithContent() && this._isEnabled) {
        yn(this.element).trigger(e); const n = yn.contains(this.element.ownerDocument.documentElement, this.element); if (e.isDefaultPrevented() || !n) return; const i = this.getTipElement(); const r = we.getUID(this.constructor.NAME); i.setAttribute('id', r), this.element.setAttribute('aria-describedby', r), this.setContent(), this.config.animation && yn(i).addClass(xn); const o = typeof this.config.placement === 'function' ? this.config.placement.call(this, i, this.element) : this.config.placement; const s = this._getAttachment(o); this.addAttachmentClass(s); const a = !1 === this.config.container ? document.body : yn(document).find(this.config.container); yn(i).data(this.constructor.DATA_KEY, this), yn.contains(this.element.ownerDocument.documentElement, this.tip) || yn(i).appendTo(a), yn(this.element).trigger(this.constructor.Event.INSERTED), this._popper = new Ct(this.element, i, {
          placement: s,
          modifiers: {
            offset: { offset: this.config.offset }, flip: { behavior: this.config.fallbackPlacement }, arrow: { element: jn }, preventOverflow: { boundariesElement: this.config.boundary },
          },
          onCreate(e) { e.originalPlacement !== e.placement && t._handlePopperPlacementChange(e); },
          onUpdate(e) { t._handlePopperPlacementChange(e); },
        }), yn(i).addClass(Pn), 'ontouchstart' in document.documentElement && yn(document.body).children().on('mouseover', null, yn.noop); const l = function () { t.config.animation && t._fixTransition(); const e = t._hoverState; t._hoverState = null, yn(t.element).trigger(t.constructor.Event.SHOWN), e === Nn && t._leave(null, t); }; if (yn(this.tip).hasClass(xn)) { const c = we.getTransitionDurationFromElement(this.tip); yn(this.tip).one(we.TRANSITION_END, l).emulateTransitionEnd(c); } else l();
      }
    }, e.hide = function (e) { const t = this; const n = this.getTipElement(); const i = yn.Event(this.constructor.Event.HIDE); const r = function () { t._hoverState !== On && n.parentNode && n.parentNode.removeChild(n), t._cleanTipClass(), t.element.removeAttribute('aria-describedby'), yn(t.element).trigger(t.constructor.Event.HIDDEN), t._popper !== null && t._popper.destroy(), e && e(); }; if (yn(this.element).trigger(i), !i.isDefaultPrevented()) { if (yn(n).removeClass(Pn), 'ontouchstart' in document.documentElement && yn(document.body).children().off('mouseover', null, yn.noop), this._activeTrigger[Fn] = !1, this._activeTrigger[Mn] = !1, this._activeTrigger[Hn] = !1, yn(this.tip).hasClass(xn)) { const o = we.getTransitionDurationFromElement(n); yn(n).one(we.TRANSITION_END, r).emulateTransitionEnd(o); } else r(); this._hoverState = ''; } }, e.update = function () { this._popper !== null && this._popper.scheduleUpdate(); }, e.isWithContent = function () { return Boolean(this.getTitle()); }, e.addAttachmentClass = function (e) { yn(this.getTipElement()).addClass(`${Tn}-${e}`); }, e.getTipElement = function () { return this.tip = this.tip || yn(this.config.template)[0], this.tip; }, e.setContent = function () { const e = this.getTipElement(); this.setElementContent(yn(e.querySelectorAll(Ln)), this.getTitle()), yn(e).removeClass(`${xn} ${Pn}`); }, e.setElementContent = function (e, t) { const n = this.config.html; typeof t === 'object' && (t.nodeType || t.jquery) ? n ? yn(t).parent().is(e) || e.empty().append(t) : e.text(yn(t).text()) : e[n ? 'html' : 'text'](t); }, e.getTitle = function () { let e = this.element.getAttribute('data-original-title'); return e || (e = typeof this.config.title === 'function' ? this.config.title.call(this.element) : this.config.title), e; }, e._getAttachment = function (e) { return An[e.toUpperCase()]; }, e._setListeners = function () { const i = this; this.config.trigger.split(' ').forEach((e) => { if (e === 'click')yn(i.element).on(i.constructor.Event.CLICK, i.config.selector, e => i.toggle(e)); else if (e !== Wn) { const t = e === Hn ? i.constructor.Event.MOUSEENTER : i.constructor.Event.FOCUSIN; const n = e === Hn ? i.constructor.Event.MOUSELEAVE : i.constructor.Event.FOCUSOUT; yn(i.element).on(t, i.config.selector, e => i._enter(e)).on(n, i.config.selector, e => i._leave(e)); }yn(i.element).closest('.modal').on('hide.bs.modal', () => i.hide()); }), this.config.selector ? this.config = l({}, this.config, { trigger: 'manual', selector: '' }) : this._fixTitle(); }, e._fixTitle = function () { const e = typeof this.element.getAttribute('data-original-title'); (this.element.getAttribute('title') || e !== 'string') && (this.element.setAttribute('data-original-title', this.element.getAttribute('title') || ''), this.element.setAttribute('title', '')); }, e._enter = function (e, t) { const n = this.constructor.DATA_KEY; (t = t || yn(e.currentTarget).data(n)) || (t = new this.constructor(e.currentTarget, this._getDelegateConfig()), yn(e.currentTarget).data(n, t)), e && (t._activeTrigger[e.type === 'focusin' ? Mn : Hn] = !0), yn(t.getTipElement()).hasClass(Pn) || t._hoverState === On ? t._hoverState = On : (clearTimeout(t._timeout), t._hoverState = On, t.config.delay && t.config.delay.show ? t._timeout = setTimeout(() => { t._hoverState === On && t.show(); }, t.config.delay.show) : t.show()); }, e._leave = function (e, t) { const n = this.constructor.DATA_KEY; (t = t || yn(e.currentTarget).data(n)) || (t = new this.constructor(e.currentTarget, this._getDelegateConfig()), yn(e.currentTarget).data(n, t)), e && (t._activeTrigger[e.type === 'focusout' ? Mn : Hn] = !1), t._isWithActiveTrigger() || (clearTimeout(t._timeout), t._hoverState = Nn, t.config.delay && t.config.delay.hide ? t._timeout = setTimeout(() => { t._hoverState === Nn && t.hide(); }, t.config.delay.hide) : t.hide()); }, e._isWithActiveTrigger = function () { for (const e in this._activeTrigger) if (this._activeTrigger[e]) return !0; return !1; }, e._getConfig = function (e) { return typeof (e = l({}, this.constructor.Default, yn(this.element).data(), typeof e === 'object' && e ? e : {})).delay === 'number' && (e.delay = { show: e.delay, hide: e.delay }), typeof e.title === 'number' && (e.title = e.title.toString()), typeof e.content === 'number' && (e.content = e.content.toString()), we.typeCheckConfig(En, e, this.constructor.DefaultType), e; }, e._getDelegateConfig = function () { const e = {}; if (this.config) for (const t in this.config) this.constructor.Default[t] !== this.config[t] && (e[t] = this.config[t]); return e; }, e._cleanTipClass = function () { const e = yn(this.getTipElement()); const t = e.attr('class').match(Sn); t !== null && t.length && e.removeClass(t.join('')); }, e._handlePopperPlacementChange = function (e) { const t = e.instance; this.tip = t.popper, this._cleanTipClass(), this.addAttachmentClass(this._getAttachment(e.placement)); }, e._fixTransition = function () { const e = this.getTipElement(); const t = this.config.animation; e.getAttribute('x-placement') === null && (yn(e).removeClass(xn), this.config.animation = !1, this.hide(), this.show(), this.config.animation = t); }, i._jQueryInterface = function (n) { return this.each(function () { let e = yn(this).data(bn); const t = typeof n === 'object' && n; if ((e || !/dispose|hide/.test(n)) && (e || (e = new i(this, t), yn(this).data(bn, e)), typeof n === 'string')) { if (typeof e[n] === 'undefined') throw new TypeError(`No method named "${n}"`); e[n](); } }); }, s(i, null, [{ key: 'VERSION', get() { return '4.1.3'; } }, { key: 'Default', get() { return In; } }, { key: 'NAME', get() { return En; } }, { key: 'DATA_KEY', get() { return bn; } }, { key: 'Event', get() { return kn; } }, { key: 'EVENT_KEY', get() { return wn; } }, { key: 'DefaultType', get() { return Dn; } }]), i;
  }()), yn.fn[En] = Rn._jQueryInterface, yn.fn[En].Constructor = Rn, yn.fn[En].noConflict = function () { return yn.fn[En] = Cn, Rn._jQueryInterface; }, Rn); const Qi = (Bn = 'popover', Kn = `.${qn = 'bs.popover'}`, Qn = (Un = t).fn[Bn], Yn = 'bs-popover', Vn = new RegExp(`(^|\\s)${Yn}\\S+`, 'g'), zn = l({}, Ki.Default, {
    placement: 'right', trigger: 'click', content: '', template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
  }), Gn = l({}, Ki.DefaultType, { content: '(string|element|function)' }), Jn = 'fade', Xn = '.popover-header', $n = '.popover-body', ei = {
    HIDE: `hide${Kn}`, HIDDEN: `hidden${Kn}`, SHOW: (Zn = 'show') + Kn, SHOWN: `shown${Kn}`, INSERTED: `inserted${Kn}`, CLICK: `click${Kn}`, FOCUSIN: `focusin${Kn}`, FOCUSOUT: `focusout${Kn}`, MOUSEENTER: `mouseenter${Kn}`, MOUSELEAVE: `mouseleave${Kn}`,
  }, ti = (function (e) { let t; let n; function i() { return e.apply(this, arguments) || this; }n = e, (t = i).prototype = Object.create(n.prototype), (t.prototype.constructor = t).__proto__ = n; const r = i.prototype; return r.isWithContent = function () { return this.getTitle() || this._getContent(); }, r.addAttachmentClass = function (e) { Un(this.getTipElement()).addClass(`${Yn}-${e}`); }, r.getTipElement = function () { return this.tip = this.tip || Un(this.config.template)[0], this.tip; }, r.setContent = function () { const e = Un(this.getTipElement()); this.setElementContent(e.find(Xn), this.getTitle()); let t = this._getContent(); typeof t === 'function' && (t = t.call(this.element)), this.setElementContent(e.find($n), t), e.removeClass(`${Jn} ${Zn}`); }, r._getContent = function () { return this.element.getAttribute('data-content') || this.config.content; }, r._cleanTipClass = function () { const e = Un(this.getTipElement()); const t = e.attr('class').match(Vn); t !== null && t.length > 0 && e.removeClass(t.join('')); }, i._jQueryInterface = function (n) { return this.each(function () { let e = Un(this).data(qn); const t = typeof n === 'object' ? n : null; if ((e || !/destroy|hide/.test(n)) && (e || (e = new i(this, t), Un(this).data(qn, e)), typeof n === 'string')) { if (typeof e[n] === 'undefined') throw new TypeError(`No method named "${n}"`); e[n](); } }); }, s(i, null, [{ key: 'VERSION', get() { return '4.1.3'; } }, { key: 'Default', get() { return zn; } }, { key: 'NAME', get() { return Bn; } }, { key: 'DATA_KEY', get() { return qn; } }, { key: 'Event', get() { return ei; } }, { key: 'EVENT_KEY', get() { return Kn; } }, { key: 'DefaultType', get() { return Gn; } }]), i; }(Ki)), Un.fn[Bn] = ti._jQueryInterface, Un.fn[Bn].Constructor = ti, Un.fn[Bn].noConflict = function () { return Un.fn[Bn] = Qn, ti._jQueryInterface; }, ti); const Yi = (ii = 'scrollspy', oi = `.${ri = 'bs.scrollspy'}`, si = (ni = t).fn[ii], ai = { offset: 10, method: 'auto', target: '' }, li = { offset: 'number', method: 'string', target: '(string|element)' }, ci = { ACTIVATE: `activate${oi}`, SCROLL: `scroll${oi}`, LOAD_DATA_API: `load${oi}.data-api` }, ui = 'dropdown-item', fi = 'active', hi = '[data-spy="scroll"]', di = '.active', pi = '.nav, .list-group', mi = '.nav-link', gi = '.nav-item', _i = '.list-group-item', vi = '.dropdown', yi = '.dropdown-item', Ei = '.dropdown-toggle', bi = 'offset', wi = 'position', Ci = (function () {
    function n(e, t) { const n = this; this._element = e, this._scrollElement = e.tagName === 'BODY' ? window : e, this._config = this._getConfig(t), this._selector = `${this._config.target} ${mi},${this._config.target} ${_i},${this._config.target} ${yi}`, this._offsets = [], this._targets = [], this._activeTarget = null, this._scrollHeight = 0, ni(this._scrollElement).on(ci.SCROLL, e => n._process(e)), this.refresh(), this._process(); } const e = n.prototype; return e.refresh = function () {
      const t = this; const e = this._scrollElement === this._scrollElement.window ? bi : wi; const r = this._config.method === 'auto' ? e : this._config.method; const o = r === wi ? this._getScrollTop() : 0; this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), [].slice.call(document.querySelectorAll(this._selector)).map((e) => { let t; const n = we.getSelectorFromElement(e); if (n && (t = document.querySelector(n)), t) { const i = t.getBoundingClientRect(); if (i.width || i.height) return [ni(t)[r]().top + o, n]; } return null; }).filter(e => e).sort((e, t) => e[0] - t[0])
        .forEach((e) => { t._offsets.push(e[0]), t._targets.push(e[1]); });
    }, e.dispose = function () { ni.removeData(this._element, ri), ni(this._scrollElement).off(oi), this._element = null, this._scrollElement = null, this._config = null, this._selector = null, this._offsets = null, this._targets = null, this._activeTarget = null, this._scrollHeight = null; }, e._getConfig = function (e) { if (typeof (e = l({}, ai, typeof e === 'object' && e ? e : {})).target !== 'string') { let t = ni(e.target).attr('id'); t || (t = we.getUID(ii), ni(e.target).attr('id', t)), e.target = `#${t}`; } return we.typeCheckConfig(ii, e, li), e; }, e._getScrollTop = function () { return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop; }, e._getScrollHeight = function () { return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight); }, e._getOffsetHeight = function () { return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height; }, e._process = function () { const e = this._getScrollTop() + this._config.offset; const t = this._getScrollHeight(); const n = this._config.offset + t - this._getOffsetHeight(); if (this._scrollHeight !== t && this.refresh(), n <= e) { const i = this._targets[this._targets.length - 1]; this._activeTarget !== i && this._activate(i); } else { if (this._activeTarget && e < this._offsets[0] && this._offsets[0] > 0) return this._activeTarget = null, void this._clear(); for (let r = this._offsets.length; r--;) { this._activeTarget !== this._targets[r] && e >= this._offsets[r] && (typeof this._offsets[r + 1] === 'undefined' || e < this._offsets[r + 1]) && this._activate(this._targets[r]); } } }, e._activate = function (t) { this._activeTarget = t, this._clear(); let e = this._selector.split(','); e = e.map(e => `${e}[data-target="${t}"],${e}[href="${t}"]`); const n = ni([].slice.call(document.querySelectorAll(e.join(',')))); n.hasClass(ui) ? (n.closest(vi).find(Ei).addClass(fi), n.addClass(fi)) : (n.addClass(fi), n.parents(pi).prev(`${mi}, ${_i}`).addClass(fi), n.parents(pi).prev(gi).children(mi).addClass(fi)), ni(this._scrollElement).trigger(ci.ACTIVATE, { relatedTarget: t }); }, e._clear = function () { const e = [].slice.call(document.querySelectorAll(this._selector)); ni(e).filter(di).removeClass(fi); }, n._jQueryInterface = function (t) { return this.each(function () { let e = ni(this).data(ri); if (e || (e = new n(this, typeof t === 'object' && t), ni(this).data(ri, e)), typeof t === 'string') { if (typeof e[t] === 'undefined') throw new TypeError(`No method named "${t}"`); e[t](); } }); }, s(n, null, [{ key: 'VERSION', get() { return '4.1.3'; } }, { key: 'Default', get() { return ai; } }]), n;
  }()), ni(window).on(ci.LOAD_DATA_API, () => { for (let e = [].slice.call(document.querySelectorAll(hi)), t = e.length; t--;) { const n = ni(e[t]); Ci._jQueryInterface.call(n, n.data()); } }), ni.fn[ii] = Ci._jQueryInterface, ni.fn[ii].Constructor = Ci, ni.fn[ii].noConflict = function () { return ni.fn[ii] = si, Ci._jQueryInterface; }, Ci); const Vi = (Di = `.${Si = 'bs.tab'}`, Ai = (Ti = t).fn.tab, Ii = {
    HIDE: `hide${Di}`, HIDDEN: `hidden${Di}`, SHOW: `show${Di}`, SHOWN: `shown${Di}`, CLICK_DATA_API: `click${Di}.data-api`,
  }, Oi = 'dropdown-menu', Ni = 'active', ki = 'disabled', xi = 'fade', Pi = 'show', Li = '.dropdown', ji = '.nav, .list-group', Hi = '.active', Mi = '> li > .active', Fi = '[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]', Wi = '.dropdown-toggle', Ri = '> .dropdown-menu .active', Ui = (function () { function i(e) { this._element = e; } const e = i.prototype; return e.show = function () { const n = this; if (!(this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && Ti(this._element).hasClass(Ni) || Ti(this._element).hasClass(ki))) { let e; let i; const t = Ti(this._element).closest(ji)[0]; const r = we.getSelectorFromElement(this._element); if (t) { const o = t.nodeName === 'UL' ? Mi : Hi; i = (i = Ti.makeArray(Ti(t).find(o)))[i.length - 1]; } const s = Ti.Event(Ii.HIDE, { relatedTarget: this._element }); const a = Ti.Event(Ii.SHOW, { relatedTarget: i }); if (i && Ti(i).trigger(s), Ti(this._element).trigger(a), !a.isDefaultPrevented() && !s.isDefaultPrevented()) { r && (e = document.querySelector(r)), this._activate(this._element, t); const l = function () { const e = Ti.Event(Ii.HIDDEN, { relatedTarget: n._element }); const t = Ti.Event(Ii.SHOWN, { relatedTarget: i }); Ti(i).trigger(e), Ti(n._element).trigger(t); }; e ? this._activate(e, e.parentNode, l) : l(); } } }, e.dispose = function () { Ti.removeData(this._element, Si), this._element = null; }, e._activate = function (e, t, n) { const i = this; const r = (t.nodeName === 'UL' ? Ti(t).find(Mi) : Ti(t).children(Hi))[0]; const o = n && r && Ti(r).hasClass(xi); const s = function () { return i._transitionComplete(e, r, n); }; if (r && o) { const a = we.getTransitionDurationFromElement(r); Ti(r).one(we.TRANSITION_END, s).emulateTransitionEnd(a); } else s(); }, e._transitionComplete = function (e, t, n) { if (t) { Ti(t).removeClass(`${Pi} ${Ni}`); const i = Ti(t.parentNode).find(Ri)[0]; i && Ti(i).removeClass(Ni), t.getAttribute('role') === 'tab' && t.setAttribute('aria-selected', !1); } if (Ti(e).addClass(Ni), e.getAttribute('role') === 'tab' && e.setAttribute('aria-selected', !0), we.reflow(e), Ti(e).addClass(Pi), e.parentNode && Ti(e.parentNode).hasClass(Oi)) { const r = Ti(e).closest(Li)[0]; if (r) { const o = [].slice.call(r.querySelectorAll(Wi)); Ti(o).addClass(Ni); }e.setAttribute('aria-expanded', !0); }n && n(); }, i._jQueryInterface = function (n) { return this.each(function () { const e = Ti(this); let t = e.data(Si); if (t || (t = new i(this), e.data(Si, t)), typeof n === 'string') { if (typeof t[n] === 'undefined') throw new TypeError(`No method named "${n}"`); t[n](); } }); }, s(i, null, [{ key: 'VERSION', get() { return '4.1.3'; } }]), i; }()), Ti(document).on(Ii.CLICK_DATA_API, Fi, function (e) { e.preventDefault(), Ui._jQueryInterface.call(Ti(this), 'show'); }), Ti.fn.tab = Ui._jQueryInterface, Ti.fn.tab.Constructor = Ui, Ti.fn.tab.noConflict = function () { return Ti.fn.tab = Ai, Ui._jQueryInterface; }, Ui); !(function (e) { if (typeof e === 'undefined') throw new TypeError("Bootstrap's JavaScript requires jQuery. jQuery must be included before Bootstrap's JavaScript."); const t = e.fn.jquery.split(' ')[0].split('.'); if (t[0] < 2 && t[1] < 9 || t[0] === 1 && t[1] === 9 && t[2] < 1 || t[0] >= 4) throw new Error("Bootstrap's JavaScript requires at least jQuery v1.9.1 but less than v4.0.0"); }(t)), e.Util = we, e.Alert = Ce, e.Button = Te, e.Carousel = Se, e.Collapse = De, e.Dropdown = Bi, e.Modal = qi, e.Popover = Qi, e.Scrollspy = Yi, e.Tab = Vi, e.Tooltip = Ki, Object.defineProperty(e, '__esModule', { value: !0 });
}));
// # sourceMappingURL=bootstrap.bundle.min.js.map
